const e=(e={})=>{const t=e.name||"",s=e.size,n=s?`height="${s}" width="${s}"`:"";return(icons[t]||"").replace("<svg",`<svg ${n} part="icon" aria-hidden="true"`).toString()},t="\n:host {\n  display: flex;\n  --height: 1em;\n  --width: 1em;\n}\n\nsvg {\n  height: var(--height);\n  width: var(--width);\n}\n";class s extends HTMLElement{static get observedAttributes(){return["name","size"]}constructor(){super(),this.shadowRoot||(this.attachShadow({mode:"open"}),this.#e||(this.shadowRoot.innerHTML=`<style>${t}</style>`))}connectedCallback(){this.#e||this.#t(this.name)}get#e(){return this.hasAttribute("server-rendered")}get name(){return this.getAttribute("name")}get size(){return this.getAttribute("size")}attributeChangedCallback(e,t,s){["name","size"].includes(e)&&t&&!this.#e&&this.#t(this.name)}async#t(e){this.removeAttribute("server-rendered");const s=window?.cekConfig?`${window.cekConfig().iconPath}/${e}.svg`:`./icons/${e}.svg`;try{const e=await fetch(s);this.dispatchEvent(new Event("cek-load"));const n=await e.text(),i=this.shadowRoot.querySelector("style");i?i.insertAdjacentHTML("afterend",n):this.shadowRoot.innerHTML=`<style>${t}</style>${n}`;const r=this.shadowRoot.querySelector("svg");r&&(r.setAttribute("part","icon"),r.setAttribute("aria-hidden","true"),this.size&&(r.style.width=this.size,r.style.height=this.size))}catch(e){console.error("fetchIcon error:",e),this.dispatchEvent(new CustomEvent("cek-error",{detail:{error:e}}))}}}customElements.define("cek-icon",s);export{s as Icon,t as iconStyles,e as iconTemplate};
